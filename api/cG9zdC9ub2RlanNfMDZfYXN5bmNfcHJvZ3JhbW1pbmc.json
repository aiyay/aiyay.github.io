{"title":"(转)Node.js搬运过来的那种Ⅵ——异步编程","date":"2018-09-11T05:19:20.000Z","author":"aiyay","excerpt":"","slug":"nodejs_06_async_programming","dropcap":true,"tags":["npm","node.js","reprint"],"categories":["Node.js"],"updated":"2018-09-11T05:48:55.770Z","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>文章来源于<a href=\"https://github.com/nqdeng/7-days-nodejs\" target=\"_blank\" rel=\"noopener\">nqdeng</a>,感谢大佬的分享;</p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><p>NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。</p>\n<h3 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h3><p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。</p>\n<pre><code>function heavyCompute(n, callback) {\n    var count = 0,\n        i, j;\n\n    for (i = n; i &gt; 0; --i) {\n        for (j = n; j &gt; 0; --j) {\n            count += 1;\n        }\n    }\n\n    callback(count);\n}\n\nheavyCompute(10000, function (count) {\n    console.log(count);\n});\n\nconsole.log(&apos;hello&apos;);\n\n-- Console ------------------------------\n100000000\nhello\n</code></pre><p>可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。</p>\n<p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。</p>\n<pre><code>setTimeout(function () {\n    console.log(&apos;world&apos;);\n}, 1000);\n\nconsole.log(&apos;hello&apos;);\n\n-- Console ------------------------------\nhello\nworld\n</code></pre><p>这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为<code>setTimeout</code>这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了<code>setTimeout</code>、<code>setInterval</code>这些常见的，这类函数还包括NodeJS提供的诸如<code>fs.readFile</code>之类的异步API。</p>\n<p>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。</p>\n<pre><code>function heavyCompute(n) {\n    var count = 0,\n        i, j;\n\n    for (i = n; i &gt; 0; --i) {\n        for (j = n; j &gt; 0; --j) {\n            count += 1;\n        }\n    }\n}\n\nvar t = new Date();\n\nsetTimeout(function () {\n    console.log(new Date() - t);\n}, 1000);\n\nheavyCompute(50000);\n\n-- Console ------------------------------\n8520\n</code></pre><p>可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。</p>\n<h3 id=\"代码设计模式\"><a href=\"#代码设计模式\" class=\"headerlink\" title=\"代码设计模式\"></a>代码设计模式</h3><p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p>\n<h4 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h4><p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：</p>\n<pre><code>var output = fn1(fn2(&apos;input&apos;));\n// Do something.\n</code></pre><p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：</p>\n<pre><code>fn2(&apos;input&apos;, function (output2) {\n    fn1(output2, function (output1) {\n        // Do something.\n    });\n});\n</code></pre><p>可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出<code>&gt;</code>形状的代码。</p>\n<h4 id=\"遍历数组\"><a href=\"#遍历数组\" class=\"headerlink\" title=\"遍历数组\"></a>遍历数组</h4><p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：</p>\n<pre><code>var len = arr.length,\n    i = 0;\n\nfor (; i &lt; len; ++i) {\n    arr[i] = sync(arr[i]);\n}\n\n// All array items have processed.\n</code></pre><p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：</p>\n<pre><code>(function next(i, len, callback) {\n    if (i &lt; len) {\n        async(arr[i], function (value) {\n            arr[i] = value;\n            next(i + 1, len, callback);\n        });\n    } else {\n        callback();\n    }\n}(0, arr.length, function () {\n    // All array items have processed.\n}));\n</code></pre><p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p>\n<p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：</p>\n<pre><code>(function (i, len, count, callback) {\n    for (; i &lt; len; ++i) {\n        (function (i) {\n            async(arr[i], function (value) {\n                arr[i] = value;\n                if (++count === len) {\n                    callback();\n                }\n            });\n        }(i));\n    }\n}(0, arr.length, 0, function () {\n    // All array items have processed.\n}));\n</code></pre><p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p>\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><p>JS自身提供的异常捕获和处理机制——<code>try..catch..</code>，只能用于同步执行的代码。以下是一个例子。</p>\n<pre><code>function sync(fn) {\n    return fn();\n}\n\ntry {\n    sync(null);\n    // Do something.\n} catch (err) {\n    console.log(&apos;Error: %s&apos;, err.message);\n}\n\n-- Console ------------------------------\nError: object is not a function\n</code></pre><p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个<code>try</code>语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到<code>try</code>语句，就作为一个全局异常抛出。以下是一个例子。</p>\n<pre><code>function async(fn, callback) {\n    // Code execution path breaks here.\n    setTimeout(function ()　{\n        callback(fn());\n    }, 0);\n}\n\ntry {\n    async(null, function (data) {\n        // Do something.\n    });\n} catch (err) {\n    console.log(&apos;Error: %s&apos;, err.message);\n}\n\n-- Console ------------------------------\n/home/user/test.js:4\n        callback(fn());\n                 ^\nTypeError: object is not a function\n    at null._onTimeout (/home/user/test.js:4:13)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n</code></pre><p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用<code>try</code>语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。</p>\n<pre><code>function async(fn, callback) {\n    // Code execution path breaks here.\n    setTimeout(function ()　{\n        try {\n            callback(null, fn());\n        } catch (err) {\n            callback(err);\n        }\n    }, 0);\n}\n\nasync(null, function (err, data) {\n    if (err) {\n        console.log(&apos;Error: %s&apos;, err.message);\n    } else {\n        // Do something.\n    }\n});\n\n-- Console ------------------------------\nError: object is not a function\n</code></pre><p>可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是<code>err</code>。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。</p>\n<p>有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个<code>try</code>语句就能捕获所有冒泡上来的异常，示例如下。</p>\n<pre><code>function main() {\n    // Do something.\n    syncA();\n    // Do something.\n    syncB();\n    // Do something.\n    syncC();\n}\n\ntry {\n    main();\n} catch (err) {\n    // Deal with exception.\n}\n</code></pre><p>但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。</p>\n<pre><code>function main(callback) {\n    // Do something.\n    asyncA(function (err, data) {\n        if (err) {\n            callback(err);\n        } else {\n            // Do something\n            asyncB(function (err, data) {\n                if (err) {\n                    callback(err);\n                } else {\n                    // Do something\n                    asyncC(function (err, data) {\n                        if (err) {\n                            callback(err);\n                        } else {\n                            // Do something\n                            callback(null);\n                        }\n                    });\n                }\n            });\n        }\n    });\n}\n\nmain(function (err) {\n    if (err) {\n        // Deal with exception.\n    }\n});\n</code></pre><p>可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。</p>\n<h3 id=\"域（Domain）\"><a href=\"#域（Domain）\" class=\"headerlink\" title=\"域（Domain）\"></a>域（Domain）</h3><blockquote>\n<p>   <strong>官方文档： </strong> <a href=\"http://nodejs.org/api/domain.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.org/api/domain.html</a></p>\n</blockquote>\n<p>NodeJS提供了<code>domain</code>模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过<code>process</code>对象提供了捕获全局异常的方法，示例代码如下</p>\n<pre><code>process.on(&apos;uncaughtException&apos;, function (err) {\n    console.log(&apos;Error: %s&apos;, err.message);\n});\n\nsetTimeout(function (fn) {\n    fn();\n});\n\n-- Console ------------------------------\nError: undefined is not a function\n</code></pre><p>虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子：</p>\n<pre><code>function async(request, callback) {\n    // Do something.\n    asyncA(request, function (err, data) {\n        if (err) {\n            callback(err);\n        } else {\n            // Do something\n            asyncB(request, function (err, data) {\n                if (err) {\n                    callback(err);\n                } else {\n                    // Do something\n                    asyncC(request, function (err, data) {\n                        if (err) {\n                            callback(err);\n                        } else {\n                            // Do something\n                            callback(null, data);\n                        }\n                    });\n                }\n            });\n        }\n    });\n}\n\nhttp.createServer(function (request, response) {\n    async(request, function (err, data) {\n        if (err) {\n            response.writeHead(500);\n            response.end();\n        } else {\n            response.writeHead(200);\n            response.end(data);\n        }\n    });\n});\n</code></pre><p>以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此<code>async</code>函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用<code>domain</code>模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的<code>error</code>事件统一捕获。于是以上代码可以做如下改造：</p>\n<pre><code>function async(request, callback) {\n    // Do something.\n    asyncA(request, function (data) {\n        // Do something\n        asyncB(request, function (data) {\n            // Do something\n            asyncC(request, function (data) {\n                // Do something\n                callback(data);\n            });\n        });\n    });\n}\n\nhttp.createServer(function (request, response) {\n    var d = domain.create();\n\n    d.on(&apos;error&apos;, function () {\n        response.writeHead(500);\n        response.end();\n    });\n\n    d.run(function () {\n        async(request, function (data) {\n            response.writeHead(200);\n            response.end(data);\n        });\n    });\n});\n</code></pre><p>可以看到，我们使用<code>.create</code>方法创建了一个子域对象，并通过<code>.run</code>方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。</p>\n<h4 id=\"陷阱\"><a href=\"#陷阱\" class=\"headerlink\" title=\"陷阱\"></a>陷阱</h4><p>无论是通过<code>process</code>对象的<code>uncaughtException</code>事件捕获到全局异常，还是通过子域对象的<code>error</code>事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>\n<p>但这里需要澄清一些事实。JS本身的<code>throw..try..catch</code>异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。</p>\n<p>因此，使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本章介绍了JS异步编程相关的知识，总结起来有以下几点：</p>\n<ul>\n<li><p>不掌握异步编程就不算学会NodeJS。</p>\n</li>\n<li><p>异步编程依托于回调来实现，而使用回调不一定就是异步编程。</p>\n</li>\n<li><p>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。</p>\n</li>\n<li><p>使用<code>domain</code>模块简化异步代码的异常处理，并小心陷阱。</p>\n</li>\n</ul>\n","prev":{"title":"(转)Node.js搬运过来的那种Ⅶ——举个大栗子","slug":"nodejs_07_example"},"next":{"title":"(转)Node.js搬运过来的那种V——进程管理","slug":"nodejs_05_process"},"link":"/2018/09/11","toc":[{"title":"异步编程","id":"异步编程","index":"1","children":[{"title":"回调","id":"回调","index":"1.1"},{"title":"代码设计模式","id":"代码设计模式","index":"1.2","children":[{"title":"函数返回值","id":"函数返回值","index":"1.2.1"},{"title":"遍历数组","id":"遍历数组","index":"1.2.2"},{"title":"异常处理","id":"异常处理","index":"1.2.3"}]},{"title":"域（Domain）","id":"域（Domain）","index":"1.3","children":[{"title":"陷阱","id":"陷阱","index":"1.3.1"}]},{"title":"小结","id":"小结","index":"1.4"}]}]}